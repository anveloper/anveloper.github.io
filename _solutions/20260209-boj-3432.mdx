---
title: "BOJ 3432 - Game"
date: "2026-02-09"
description: "구현, 브루트포스 알고리즘 문제"
tags: ["구현", "브루트포스 알고리즘"]
platform: "boj"
problem_number: "3432"
problem_url: "https://www.acmicpc.net/problem/3432"
difficulty: "브론즈 I"
language: "cpp"
---

## 문제

[BOJ 3432 - Game](https://www.acmicpc.net/problem/3432)

## 풀이

문제의 조건을 그대로 구현한다.

## 코드

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// 5x5 판이므로 고정 크기 배열 사용
char board[5][5];

void solve() {
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            cin >> board[i][j];
        }
    }

    bool a_wins = false;
    bool b_wins = false;

    // 8방향 중 중복을 제외한 4방향(우, 하, 우하, 좌하) 탐색을 위한 델타값
    int dr[] = {0, 1, 1, 1};
    int dc[] = {1, 0, 1, -1};

    for (int r = 0; r < 5; ++r) {
        for (int c = 0; c < 5; ++c) {
            char curr = board[r][c];
            
            for (int d = 0; d < 4; ++d) {
                int r2 = r + dr[d], c2 = c + dc[d];
                int r3 = r + 2 * dr[d], c3 = c + 2 * dc[d];

                // 판 범위 내에 있는지 확인 후 3목 체크
                if (r3 >= 0 && r3 < 5 && c3 >= 0 && c3 < 5) {
                    if (curr == board[r2][c2] && curr == board[r3][c3]) {
                        if (curr == 'A') a_wins = true;
                        else if (curr == 'B') b_wins = true;
                    }
                }
            }
        }
    }

    // 결과 출력 조건
    if (a_wins && b_wins) cout << "draw\n";
    else if (a_wins) cout << "A wins\n";
    else if (b_wins) cout << "B wins\n";
    else cout << "draw\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int t;
    if (!(cin >> t)) return 0;
    while (t--) {
        solve();
    }
    return 0;
}
```

## 복잡도

- 시간: O(N²)
- 공간: O(N)
