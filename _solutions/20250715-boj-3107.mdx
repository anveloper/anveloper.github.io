---
title: "BOJ 3107 - IPv6"
date: "2025-07-15"
description: "구현, 문자열 문제"
tags: ["구현", "문자열"]
platform: "boj"
problem_number: "3107"
problem_url: "https://www.acmicpc.net/problem/3107"
difficulty: "실버 I"
language: "python"
enhanced: true
---

## 문제

[BOJ 3107 - IPv6](https://www.acmicpc.net/problem/3107)

축약된 IPv6 주소가 주어질 때, 축약을 해제하여 완전한 형태로 출력하라. IPv6 축약 규칙은 다음과 같다:
- 각 그룹의 앞쪽 0은 생략할 수 있다 (예: `0001` → `1`)
- 연속된 0 그룹은 `::`로 축약할 수 있다

### 입력

축약된 IPv6 주소가 주어진다.

### 출력

8개 그룹이 `:`으로 구분된 완전한 IPv6 주소를 출력한다. 각 그룹은 4자리 16진수이다.

### 예제

| 입력 | 출력 |
|------|------|
| `25:09:1985:aa:091:4846:374:bb` | `0025:0009:1985:00aa:0091:4846:0374:00bb` |
| `::1` | `0000:0000:0000:0000:0000:0000:0000:0001` |

## 풀이

`::`를 처리하여 생략된 0 그룹을 복원하고, 각 그룹을 4자리로 패딩한다.

1. 입력을 `:`로 분리한다
2. 맨 앞이나 맨 뒤의 빈 문자열을 제거한다 (`::1` → `["", "", "1"]`에서 앞쪽 빈 문자열 제거)
3. 분리된 각 요소를 순회한다:
   - 빈 문자열이면 `::`에 해당하므로, `8 - (현재 그룹 수) + 1`개의 `0000`을 채운다
   - 빈 문자열이 아니면 `zfill(4)`로 4자리로 패딩한다
4. 결과에서 마지막 `:`을 제거하고 출력한다

**핵심 아이디어**: `::`로 분리하면 빈 문자열이 생기는 점을 이용하여, 빈 문자열의 위치에 필요한 만큼의 `0000` 그룹을 삽입한다.

## 코드

```python
ipv6 = input()
ipv6 = ipv6.split(":")
if ipv6[0] == "":
    ipv6 = ipv6[1:]
if ipv6[-1] == "":
    ipv6 = ipv6[:-1]

result = ""
for i in ipv6:
    if i == "":
        result += "0000:" * (8 - len(ipv6) + 1)
    else:
        result += i.zfill(4) + ":"

print(result[:-1])
```

## 복잡도

- 시간: O(N) — 그룹 수에 비례 (최대 8개)
- 공간: O(N) — 결과 문자열 저장
