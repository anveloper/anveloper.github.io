---
title: "BOJ 4619 - 루트"
date: "2024-10-26"
description: "a^n이 b에 가장 가까운 a를 찾는 브루트포스 문제"
tags: ["수학", "브루트포스 알고리즘"]
platform: "boj"
problem_number: "4619"
problem_url: "https://www.acmicpc.net/problem/4619"
difficulty: "브론즈 III"
language: "cpp"
---

## 문제

[BOJ 4619 - 루트](https://www.acmicpc.net/problem/4619)

> b와 n이 주어졌을 때, a^n이 b에 가장 가까운 양의 정수 a를 구한다.

## 풀이

a를 1부터 증가시키면서 a^n을 계산하고 b와의 차이를 구한다. 차이가 가장 작은 a를 추적하며, a^n이 2,000,000을 초과하면 탐색을 종료한다. b와 n이 모두 0이면 입력을 종료한다.

## 코드

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
  while (1)
  {
    int b, n;
    cin >> b >> n;
    if (!b && !n)
      break;
    int minDiff = 0x3f3f3f3f;
    int minVal = 0x3f3f3f3f;
    for (int a = 1; pow(a, n) <= 2000000; a++)
    {
      int diff = abs(pow(a, n) - b);
      if (diff < minDiff)
        minDiff = diff, minVal = a;
    }
    cout << minVal << '\n';
  }
}
```

## 복잡도

- 시간: O(T * 2000000^(1/n))
- 공간: O(1)
