---
title: "BOJ 3486 - Adding Reversed Numbers"
date: "2025-12-03"
description: "수학, 구현, 문자열 문제"
tags: ["수학", "구현", "문자열", "사칙연산"]
platform: "boj"
problem_number: "3486"
problem_url: "https://www.acmicpc.net/problem/3486"
difficulty: "브론즈 II"
language: "cpp"
enhanced: true
---

## 문제

[BOJ 3486 - Adding Reversed Numbers](https://www.acmicpc.net/problem/3486)

두 양의 정수 A, B가 주어질 때, 각각을 뒤집은(reversed) 수를 더한 후, 그 결과를 다시 뒤집어서 출력하는 문제이다.

예를 들어 A = 24, B = 1 이면, 뒤집으면 42와 1이 되고, 합은 43, 다시 뒤집으면 34가 된다.

중요한 점은 결과를 뒤집은 후 앞의 0은 제거해야 한다는 점이다. 예를 들어 합이 100이면 뒤집으면 001이지만, 실제 정수로는 1이 되어야 한다.

### 입력

- 첫째 줄에 테스트 케이스 수 T가 주어진다.
- 각 테스트 케이스마다 두 정수 A, B가 주어진다. (1 이상 10000 이하)

### 출력

각 테스트 케이스에 대해 뒤집어 더하고 다시 뒤집은 결과를 출력한다.

### 예제

| 입력 | 출력 |
|------|------|
| `1` `24 1` | `34` |

## 풀이

문자열로 입력받아 뒤집고, 정수로 변환해 더한 뒤, 결과를 다시 문자열로 변환해 뒤집는다.

1. T개의 테스트 케이스를 처리한다.
2. 두 수 A, B를 문자열로 읽은 후 `reverse()`로 뒤집는다.
3. `stoi()`로 정수 변환 후 합산한다. (이 과정에서 앞의 0이 자동 제거됨)
4. 합을 `to_string()`으로 문자열로 변환 후 `reverse()`로 다시 뒤집는다.
5. `stoi()`로 최종 변환하여 출력한다. (뒤의 0 제거)

**핵심 아이디어**: 문자열 뒤집기와 `stoi()` 변환을 조합하면 앞뒤의 불필요한 0을 자동으로 처리할 수 있다. 숫자를 직접 자릿수 분리하는 것보다 문자열로 다루는 것이 훨씬 간결하다.

## 코드

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
  int t;
  cin >> t;
  while (t--)
  {
    string a, b, c;
    cin >> a >> b;
    reverse(a.begin(), a.end());
    reverse(b.begin(), b.end());
    c = to_string(stoi(a) + stoi(b));
    reverse(c.begin(), c.end());
    cout << stoi(c) << "\n";
  }
}
```

## 복잡도

- 시간: O(T * D) — T개의 테스트 케이스, 각 수의 자릿수 D만큼 처리
- 공간: O(D) — 문자열 저장
