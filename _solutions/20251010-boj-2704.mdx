---
title: "BOJ 2704 - 이진법 시계"
date: "2025-10-10"
description: "구현 문제"
tags: ["구현"]
platform: "boj"
problem_number: "2704"
problem_url: "https://www.acmicpc.net/problem/2704"
difficulty: "브론즈 II"
language: "cpp"
enhanced: true
---

## 문제

[BOJ 2704 - 이진법 시계](https://www.acmicpc.net/problem/2704)

`HH:MM:SS` 형식의 시각이 주어지면 이진법 시계 형태의 두 가지 표현으로 변환하여 출력한다. 첫 번째는 시·분·초를 비트 단위로 교차 배치한 18비트 문자열이고, 두 번째는 시·분·초를 각각 6비트씩 이어붙인 18비트 문자열이다. 두 표현은 공백으로 구분하여 한 줄에 출력한다.

### 입력

첫 줄에 테스트 케이스 수 T가 주어진다. 이후 T줄에 걸쳐 `HH:MM:SS` 형식의 시각이 주어진다.

### 출력

각 테스트 케이스에 대해 교차 배치 방식과 순차 배치 방식의 이진 표현을 공백으로 구분하여 출력한다.

### 예제

| 입력           | 출력                                    |
| -------------- | --------------------------------------- |
| `1` `15:06:30` | `011000011001001110 001111000110011110` |

## 풀이

문자열에서 시·분·초를 파싱한 후, 비트 연산을 이용해 두 가지 이진 표현을 생성한다.

1. `substr`로 `HH`, `MM`, `SS` 부분을 추출하고 `stoi`로 정수 변환한다.
2. **교차 배치**: 최상위 비트(k=5)부터 최하위 비트(k=0)까지 반복하며, 각 비트 위치에서 시(H), 분(M), 초(S) 순으로 해당 비트를 출력한다. 비트 확인은 `& (1 << k)` 연산을 사용한다.
3. **순차 배치**: 동일한 비트 범위를 H, M, S 각각 독립적으로 반복하며 출력한다.
4. 두 표현 사이에 공백을 출력하고, 각 케이스 뒤에 개행한다.

**핵심 아이디어**: 시간을 정수로 변환한 뒤 비트 마스크 `(1 << k)`로 각 비트를 추출하면 이진 문자열 변환을 간결하게 처리할 수 있다. 교차 배치는 동일 루프 안에서 H·M·S를 번갈아 출력하고, 순차 배치는 세 개의 독립적인 루프로 처리한다.

## 코드

```cpp
#include <iostream>
#include <string>
using namespace std;

int T;
string s;

int main()
{
  ios::sync_with_stdio(0);
  cin.tie(0);

  cin >> T;
  while (T--)
  {
    cin >> s;
    int H = stoi(s.substr(0, 2)), M = stoi(s.substr(3, 2)), S = stoi(s.substr(6, 2));

    for (int k = 5; k > -1; k--)
    {
      if (H & (1 << k))
        cout << 1;
      else
        cout << 0;
      if (M & (1 << k))
        cout << 1;
      else
        cout << 0;
      if (S & (1 << k))
        cout << 1;
      else
        cout << 0;
    }

    cout << ' ';

    for (int k = 5; k > -1; k--)
    {
      if (H & (1 << k))
        cout << 1;
      else
        cout << 0;
    }
    for (int k = 5; k > -1; k--)
    {
      if (M & (1 << k))
        cout << 1;
      else
        cout << 0;
    }
    for (int k = 5; k > -1; k--)
    {
      if (S & (1 << k))
        cout << 1;
      else
        cout << 0;
    }

    cout << '\n';
  }
}
```

## 복잡도

- 시간: O(T) — 각 케이스마다 6비트씩 고정 횟수 반복
- 공간: O(1) — 상수 크기 변수만 사용
