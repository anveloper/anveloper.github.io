---
title: "BOJ 1005 - ACM Craft"
date: "2023-03-08"
description: "다이나믹 프로그래밍, 그래프 이론, dag 문제"
tags: ["다이나믹 프로그래밍", "그래프 이론", "dag", "위상 정렬"]
platform: "boj"
problem_number: "1005"
problem_url: "https://www.acmicpc.net/problem/1005"
difficulty: "골드 III"
language: "java"
---

## 문제

[BOJ 1005 - ACM Craft](https://www.acmicpc.net/problem/1005)

## 풀이

다이나믹 프로그래밍을 사용하여 부분 문제의 해를 메모이제이션하며 풀이한다. 위상 정렬을 사용하여 순서를 결정한다.

## 코드

```java
package day399;

import java.io.*;
import java.util.*;

public class Day395BOJ1005ACMCraft { // g
  static final int MAX = 1001;
  static int N, K;
  static int[] buildTimes, indegs, minTimes;
  static ArrayList<ArrayList<Integer>> posteriors = new ArrayList<>();

  public static void main(String[] args) throws IOException {
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

    for (int tc = readInt(); tc > 0; --tc) {
      N = readInt();
      K = readInt();
      indegs = new int[N + 1];
      minTimes = new int[N + 1];
      buildTimes = new int[N + 1];
      posteriors.clear();
      posteriors.add(null);
      for (int i = 1; i <= N; ++i) {
        posteriors.add(new ArrayList<>());
        buildTimes[i] = readInt();
      }

      for (; K > 0; --K) {
        int anterior = readInt();
        int posterior = readInt();
        indegs[posterior]++;
        posteriors.get(anterior).add(posterior);
      }

      int id = readInt();
      int minT = getMinTime(id);
      bw.write(minT + "\n");
    }
    bw.flush();
    bw.close();
  }

  static int getMinTime(int id) {
    Queue<Integer> q = new ArrayDeque<>();

    for (int i = 1; i <= N; ++i) {
      if (indegs[i] != 0)
        continue;
      if (i == id)
        return buildTimes[i];
      minTimes[i] = buildTimes[i];
      q.add(i);
    }

    LOOP: while (!q.isEmpty()) {
      int i = q.poll();
      for (int posterior : posteriors.get(i)) {
        minTimes[posterior] = Math.max(minTimes[i], minTimes[posterior]);
        if (--indegs[posterior] > 0)
          continue;
        minTimes[posterior] += buildTimes[posterior];
        if (posterior == id)
          break LOOP;
        q.add(posterior);
      }
    }
    return minTimes[id];
  }

  static int readInt() throws IOException {
    int val = 0;
    do {
      int c = System.in.read();
      if (c == ' ' || c == '\n')
        break;
      val = 10 * val + c - 48;
    } while (true);
    return val;
  }

}
```

## 복잡도

- 시간: O(N²)
- 공간: O(N)
