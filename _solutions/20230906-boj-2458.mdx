---
title: "BOJ 2458 - 키 순서"
date: "2023-09-06"
description: "그래프 이론, 그래프 탐색, 최단 경로 문제"
tags: ["그래프 이론", "그래프 탐색", "최단 경로", "깊이 우선 탐색", "플로이드–워셜"]
platform: "boj"
problem_number: "2458"
problem_url: "https://www.acmicpc.net/problem/2458"
difficulty: "골드 IV"
language: "java"
---

## 문제

[BOJ 2458 - 키 순서](https://www.acmicpc.net/problem/2458)

## 풀이

그래프 탐색(BFS/DFS)을 활용하여 탐색한다. 깊이 우선 탐색(DFS)을 활용하여 탐색한다.

## 코드

```java
package day599;

import java.io.*;
import java.util.*;

public class Day579BOJ2458키순서 {
  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer st = new StringTokenizer(br.readLine());
    int n = Integer.parseInt(st.nextToken());
    int m = Integer.parseInt(st.nextToken());
    boolean[][] check = new boolean[n][n];
    for (int i = 0; i < m; i++) {
      st = new StringTokenizer(br.readLine());
      int a = Integer.parseInt(st.nextToken()) - 1;
      int b = Integer.parseInt(st.nextToken()) - 1;
      check[a][b] = true;
    }

    for (int k = 0; k < n; k++) {
      for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
          if (check[i][k] && check[k][j]) {
            check[i][j] = true;
          }
        }
      }
    }

    int[] cnt = new int[n];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (check[i][j] || check[j][i]) {
          cnt[i]++;
        }
      }
    }

    int res = 0;
    for (int num : cnt) {
      if (num == n - 1)
        res++;
    }
    System.out.println(res);
  }
}
```

## 복잡도

- 시간: O(V³)
- 공간: O(V²)
