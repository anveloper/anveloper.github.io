---
title: "BOJ 9610 - 사분면"
date: "2026-01-10"
description: "수학, 구현 문제"
tags: ["수학", "구현"]
platform: "boj"
problem_number: "9610"
problem_url: "https://www.acmicpc.net/problem/9610"
difficulty: "브론즈 III"
language: "cpp"
enhanced: true
---

## 문제

[BOJ 9610 - 사분면](https://www.acmicpc.net/problem/9610)

N개의 점 (x, y)가 주어질 때, 각 점이 어느 사분면에 속하는지, 또는 축 위에 있는지 분류하여 개수를 출력하는 문제이다.

- 1사분면: `x > 0` 이고 `y > 0`
- 2사분면: `x < 0` 이고 `y > 0`
- 3사분면: `x < 0` 이고 `y < 0`
- 4사분면: `x > 0` 이고 `y < 0`
- AXIS: x축 또는 y축 위 (x = 0 또는 y = 0)

### 입력

- 첫 번째 줄에 점의 수 N (1 이상)이 주어진다.
- 다음 N개의 줄에 각 점의 좌표 x, y가 주어진다.

### 출력

```
Q1: (1사분면 점 개수)
Q2: (2사분면 점 개수)
Q3: (3사분면 점 개수)
Q4: (4사분면 점 개수)
AXIS: (축 위 점 개수)
```

### 예제

| 입력                                  | 출력                                      |
| ------------------------------------- | ----------------------------------------- |
| `5` `1 2` `-3 4` `-1 -1` `2 -2` `0 5` | `Q1: 1` `Q2: 1` `Q3: 1` `Q4: 1` `AXIS: 1` |

## 풀이

각 점의 좌표 부호를 확인하여 사분면을 결정하고, 결과를 누적 카운트하는 단순 분기 구현 문제이다.

1. N개의 점 좌표를 입력받는다.
2. x, y의 부호 조합에 따라 1~4사분면, 또는 AXIS로 분류한다.
3. 각 분류별 카운트 배열에 누적한다.
4. 형식에 맞게 결과를 출력한다.

**핵심 아이디어**: x = 0 또는 y = 0인 경우는 사분면이 아닌 축(AXIS)으로 처리한다. if-else if 체인에서 마지막 else가 AXIS 케이스를 자연스럽게 포착한다.

## 코드

```cpp
#include <iostream>

using namespace std;

int main()
{
  cin.tie(NULL);
  ios::sync_with_stdio(false);

  int n;
  cin >> n;

  int ans[5] = {};

  int x, y;

  for (int i = 0; i < n; i++)
  {
    cin >> x >> y;

    if (x > 0 && y > 0)
      ans[0]++;
    else if (x < 0 && y > 0)
      ans[1]++;
    else if (x < 0 && y < 0)
      ans[2]++;
    else if (x > 0 && y < 0)
      ans[3]++;
    else
      ans[4]++;
  }
  for (int i = 0; i < 4; i++)
  {
    cout << "Q" << i + 1 << ": " << ans[i] << "\n";
  }
  cout << "AXIS: " << ans[4] << "\n";
}
```

## 복잡도

- 시간: O(N) - 점의 수 N에 비례하여 순회
- 공간: O(1) - 크기 5의 고정 배열만 사용
