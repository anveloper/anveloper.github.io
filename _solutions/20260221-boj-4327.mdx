---
title: "BOJ 4327 - Combination Lock"
date: "2026-02-21"
description: "구현, 수학 문제"
tags: ["구현", "수학"]
platform: "boj"
problem_number: "4327"
problem_url: "https://www.acmicpc.net/problem/4327"
difficulty: "브론즈 II"
language: "cpp"
enhanced: true
---

## 문제

[BOJ 4327 - Combination Lock](https://www.acmicpc.net/problem/4327)

조합 자물쇠 다이얼에는 0부터 39까지 40개의 눈금이 있으며, 눈금 하나의 간격은 9도(360/40)이다. 자물쇠를 여는 절차는 다음과 같다.

1. 시계 방향(CW)으로 2바퀴 돌려 첫 번째 숫자에 맞춘다.
2. 반시계 방향(CCW)으로 1바퀴를 지나 두 번째 숫자에 맞춘다.
3. 시계 방향(CW)으로 세 번째 숫자에 맞춘다.

초기 위치와 세 조합 숫자가 주어질 때, 총 회전 각도를 구한다. `0 0 0 0`이면 종료한다.

### 입력

- 각 줄에 4개의 정수: 초기 위치, 첫 번째 숫자, 두 번째 숫자, 세 번째 숫자
- `0 0 0 0`이면 입력 종료

### 출력

각 테스트 케이스마다 총 회전 각도(정수)를 출력한다.

### 예제

| 입력 | 출력 |
|------|------|
| `0 30 0 30` | `1350` |
| `5 35 5 35` | `1350` |

## 풀이

다이얼 회전의 총 각도를 구간별로 분해하여 계산한다.

1. 시계 방향 2바퀴 회전: 720도
2. 첫 번째 숫자까지 시계 방향 추가 회전: `(A[0] - A[1] + 40) % 40 * 9`도
3. 두 번째 숫자까지 반시계 방향 1바퀴 + 추가 회전: 360도 + `(A[2] - A[1] + 40) % 40 * 9`도
4. 세 번째 숫자까지 시계 방향 회전: `(A[2] - A[3] + 40) % 40 * 9`도

기본 고정값은 720 + 360 = 1080도이고, 나머지 세 구간의 눈금 차이에 9를 곱해 더한다.

**핵심 아이디어**: 원형 다이얼에서 두 눈금 사이의 거리를 `(시작 - 도착 + 40) % 40`으로 계산하면 방향에 맞는 양의 거리를 얻는다. 시계 방향과 반시계 방향 모두 동일한 모듈러 연산 패턴을 적용할 수 있다.

## 코드

```cpp
#include <iostream>

using namespace std;

int main() {
  ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

  while (1) {
    int A[4]; cin >> A[0] >> A[1] >> A[2] >> A[3];
    if (A[0] == 0 && A[1] == 0 && A[2] == 0 && A[3] == 0) break;
    cout << 1080 + (A[0] - A[1] + 40) % 40 * 9 + (A[2] - A[1] + 40) % 40 * 9 + (A[2] - A[3] + 40) % 40 * 9 << '\n';
  }
}
```

## 복잡도

- 시간: O(T) — 테스트 케이스당 O(1) 산술 연산
- 공간: O(1) — 고정 크기 배열만 사용
