---
title: "BOJ 1986 - 체스"
date: "2025-07-15"
description: "구현 문제"
tags: ["구현"]
platform: "boj"
problem_number: "1986"
problem_url: "https://www.acmicpc.net/problem/1986"
difficulty: "실버 I"
language: "python"
---

## 문제

[BOJ 1986 - 체스](https://www.acmicpc.net/problem/1986)

## 풀이

문제의 조건을 그대로 구현한다.

## 코드

```python
import sys

input = sys.stdin.readline

N, M = map(int, input().split())


def read_pieces():
    data = list(map(int, input().split()))
    k, coords = data[0], data[1:]
    pieces = [(coords[i], coords[i + 1]) for i in range(0, 2 * k, 2)]
    return pieces


queens = read_pieces()
knights = read_pieces()
pawns = read_pieces()

occupied = [[False] * (M + 1) for _ in range(N + 1)]
unsafe = [[False] * (M + 1) for _ in range(N + 1)]

for x, y in queens + knights + pawns:
    occupied[x][y] = True

dirs = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]
for qx, qy in queens:
    for dx, dy in dirs:
        nx, ny = qx + dx, qy + dy
        while 1 <= nx <= N and 1 <= ny <= M:
            unsafe[nx][ny] = True
            if occupied[nx][ny]:
                break
            nx += dx
            ny += dy

k_moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]
for kx, ky in knights:
    for dx, dy in k_moves:
        nx, ny = kx + dx, ky + dy
        if 1 <= nx <= N and 1 <= ny <= M:
            unsafe[nx][ny] = True

safe_cnt = 0
for r in range(1, N + 1):
    for c in range(1, M + 1):
        if not occupied[r][c] and not unsafe[r][c]:
            safe_cnt += 1

print(safe_cnt)
```

## 복잡도

- 시간: O(N)
- 공간: O(N)
