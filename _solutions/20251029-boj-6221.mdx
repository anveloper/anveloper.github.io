---
title: "BOJ 6221 - The Bale Tower"
date: "2025-10-29"
description: "다이나믹 프로그래밍, 브루트포스 알고리즘, 정렬 문제"
tags: ["다이나믹 프로그래밍", "브루트포스 알고리즘", "정렬", "가장 긴 증가하는 부분 수열"]
platform: "boj"
problem_number: "6221"
problem_url: "https://www.acmicpc.net/problem/6221"
difficulty: "실버 III"
language: "cpp"
---

## 문제

[BOJ 6221 - The Bale Tower](https://www.acmicpc.net/problem/6221)

## 풀이

다이나믹 프로그래밍을 사용하여 부분 문제의 해를 메모이제이션하며 풀이한다.

## 코드

```cpp
#include <iostream>
#include <utility>
#include <algorithm>
#include <vector>

using namespace std;
using pii = pair<int, int>;

vector<pii> v;

int dp[21];
int main()
{
  int N;
  cin >> N;
  int res = 1;
  for (int i = 0; i < N; ++i)
  {
    int x1, x2;
    cin >> x1 >> x2;
    v.push_back({x1, x2});
  }
  sort(v.begin(), v.end(), greater<pii>());
  dp[0] = 1;
  for (int i = 1; i < N; ++i)
  {
    dp[i] = 1;
    for (int j = 0; j < i; ++j)
    {
      if (v[i].first < v[j].first && v[i].second < v[j].second)
        dp[i] = max(dp[i], dp[j] + 1);
      res = max(res, dp[i]);
    }
  }
  cout << res << '\n';
}
```

## 복잡도

- 시간: O(N²)
- 공간: O(N)
