---
title: "BOJ 6324 - URLs"
date: "2025-10-24"
description: "문자열, 많은 조건 분기, 파싱 문제"
tags: ["문자열", "많은 조건 분기", "파싱"]
platform: "boj"
problem_number: "6324"
problem_url: "https://www.acmicpc.net/problem/6324"
difficulty: "실버 I"
language: "cpp"
enhanced: true
---

## 문제

[BOJ 6324 - URLs](https://www.acmicpc.net/problem/6324)

URL을 파싱하여 프로토콜, 호스트, 포트, 경로를 분리하여 출력하라. 없는 부분은 `<default>`로 표시한다.

### 입력

URL 개수 N과 N개의 URL이 주어진다.

### 출력

각 URL의 프로토콜, 호스트, 포트, 경로를 형식에 맞게 출력한다.

### 예제

| 입력                              | 출력                             |
| --------------------------------- | -------------------------------- |
| `1` `http://example.com:80/index` | `URL #1` `Protocol = http` `...` |

## 풀이

정규 표현식으로 URL의 각 구성 요소를 추출한다.

1. `프로토콜://호스트:포트/경로` 형태의 정규식을 정의한다
2. 각 캡처 그룹이 비어 있으면 `<default>`를 할당한다
3. 포트의 선행 `:` 와 경로의 선행 `/`를 제거한다
4. 형식에 맞게 출력한다

**핵심 아이디어**: C++ `std::regex`로 URL 구조를 한 번에 파싱하며, 선택적 구성 요소는 정규식의 `?` 한정자로 처리한다.

## 코드

```cpp
#include <iostream>
#include <regex>
#include <string>

using namespace std;

int main()
{
  regex r(R"((^\w+)://([^:/]+)(:\d+)?(/.+$)?)");
  int N;
  cin >> N;
  for (int n = 1; n <= N; n++)
  {
    string s, ans[4];
    cin >> s;
    auto it = *sregex_iterator(s.begin(), s.end(), r);
    for (int i = 0; i < 4; i++)
    {
      ans[i] = it[i + 1];
      if (ans[i].empty())
        ans[i] = "<default>";
    }
    if (ans[2][0] == ':')
      ans[2] = ans[2].substr(1);
    if (ans[3][0] == '/')
      ans[3] = ans[3].substr(1);
    cout << "URL #" << n << '\n';
    cout << "Protocol = " << ans[0] << '\n';
    cout << "Host     = " << ans[1] << '\n';
    cout << "Port     = " << ans[2] << '\n';
    cout << "Path     = " << ans[3] << '\n'
         << '\n';
  }
}
```

## 복잡도

- 시간: O(N \* L) (L: URL 길이)
- 공간: O(L)
