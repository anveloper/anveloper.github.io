---
title: "BOJ 12851 - 숨바꼭질 2"
date: "2023-10-13"
description: "그래프 이론, 그래프 탐색, 너비 우선 탐색 문제"
tags: ["그래프 이론", "그래프 탐색", "너비 우선 탐색"]
platform: "boj"
problem_number: "12851"
problem_url: "https://www.acmicpc.net/problem/12851"
difficulty: "골드 IV"
language: "java"
---

## 문제

[BOJ 12851 - 숨바꼭질 2](https://www.acmicpc.net/problem/12851)

## 풀이

그래프 탐색(BFS/DFS)을 활용하여 탐색한다.

## 코드

```java
package day649;

import java.util.*;
import java.io.*;

class Day616BOJ12851숨바꼭질2 {
  static int N, K;
  static int[] time = new int[100001];
  static int minTime = 987654321;
  static int count = 0;

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer st;

    st = new StringTokenizer(br.readLine());
    N = Integer.parseInt(st.nextToken());
    K = Integer.parseInt(st.nextToken());

    if (N >= K) {
      System.out.println((N - K) + "\n1");
      return;
    }

    bfs();

    System.out.println(minTime + "\n" + count);
  }

  static void bfs() {
    Queue<Integer> q = new LinkedList<Integer>();

    q.add(N);
    time[N] = 1;

    while (!q.isEmpty()) {
      int now = q.poll();

      if (minTime < time[now])
        return;

      for (int i = 0; i < 3; i++) {
        int next;

        if (i == 0)
          next = now + 1;
        else if (i == 1)
          next = now - 1;
        else
          next = now * 2;

        if (next < 0 || next > 100000)
          continue;

        if (next == K) {
          minTime = time[now];
          count++;
        }

        if (time[next] == 0 || time[next] == time[now] + 1) {
          q.add(next);
          time[next] = time[now] + 1;
        }
      }
    }
  }
}
```

## 복잡도

- 시간: O(V + E)
- 공간: O(V + E)
