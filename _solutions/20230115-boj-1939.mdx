---
title: "BOJ 1939 - 중량제한"
date: "2023-01-15"
description: "그래프 이론, 자료 구조, 그래프 탐색 문제"
tags: ["그래프 이론", "자료 구조", "그래프 탐색", "이분 탐색", "너비 우선 탐색", "최단 경로", "데이크스트라", "분리 집합"]
platform: "boj"
problem_number: "1939"
problem_url: "https://www.acmicpc.net/problem/1939"
difficulty: "골드 III"
language: "java"
---

## 문제

[BOJ 1939 - 중량제한](https://www.acmicpc.net/problem/1939)

## 풀이

그래프 탐색(BFS/DFS)을 활용하여 탐색한다. 이분 탐색을 통해 최적의 값을 탐색한다.

## 코드

```java
package day349;

import java.io.*;
import java.util.*;

public class Day342BOJ1939중량제한 {

    static class Node {
        int end;
        int w;

        public Node(int end, int w) {
            this.end = end;
            this.w = w;
        }
    }

    static int N, maxC, maxWeight = 0;
    static ArrayList<Node>[] adjList;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        adjList = new ArrayList[N];
        for (int i = 0; i < N; i++) {
            adjList[i] = new ArrayList<Node>();
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int A = Integer.parseInt(st.nextToken()) - 1;
            int B = Integer.parseInt(st.nextToken()) - 1;
            int C = Integer.parseInt(st.nextToken());

            adjList[A].add(new Node(B, C));
            adjList[B].add(new Node(A, C));

            maxC = Math.max(C, maxC);
        }

        st = new StringTokenizer(br.readLine());
        int factoryA = Integer.parseInt(st.nextToken()) - 1;
        int factoryB = Integer.parseInt(st.nextToken()) - 1;

        findMaxWeight(factoryA, factoryB);

        System.out.println(maxWeight);
    }

    private static void findMaxWeight(int factoryA, int factoryB) {

        int low = 1;
        int high = maxC;

        Queue<Integer> q = new LinkedList<Integer>();
        boolean[] checked = new boolean[N];

        while (low <= high) {

            int mid = (low + high) / 2;
            q.add(factoryA);
            checked[factoryA] = true;

            boolean existed = existPossibleRoute(q, checked, mid, factoryB);

            if (existed) {
                maxWeight = Math.max(maxWeight, mid);
                low = mid + 1;
            } else {
                high = mid - 1;
            }

            q.clear();
            Arrays.fill(checked, false);
        }
    }

    private static boolean existPossibleRoute(Queue<Integer> q, boolean[] checked, int mid, int end) {

        while (!q.isEmpty()) {
            int from = q.poll();

            for (Node v : adjList[from]) {
                if (v.w >= mid) {
                    if (from == end) {
                        return true;
                    }
                    if (!checked[v.end]) {
                        checked[v.end] = true;
                        q.add(v.end);
                    }
                }
            }
        }
        return false;
    }

}
```

## 복잡도

- 시간: O((V + E) log V)
- 공간: O(V + E)
