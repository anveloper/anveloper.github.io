---
title: "BOJ 1326 - 폴짝폴짝"
date: "2024-04-27"
description: "징검다리에서 최소 점프 횟수로 목표에 도달하는 문제"
tags: ["그래프", "BFS"]
platform: "boj"
problem_number: "1326"
problem_url: "https://www.acmicpc.net/problem/1326"
difficulty: "실버 II"
language: "javascript"
---

## 문제

[BOJ 1326 - 폴짝폴짝](https://www.acmicpc.net/problem/1326)

> N개의 징검다리에 적힌 수의 배수만큼 양방향으로 점프할 수 있을 때, 출발점에서 도착점까지의 최소 점프 횟수를 구한다.

## 풀이

BFS로 현재 돌에서 점프력의 배수만큼 양방향으로 이동 가능한 돌을 탐색한다. 방문 배열로 중복 방문을 방지한다.

## 코드

```javascript
const solution = (input) => {
  const N = +input[0];
  const stones = input[1].trim().split(" ").map(Number);
  const [A, B] = input[2].trim().split(" ").map(Number);

  const a = A - 1;
  const b = B - 1;

  if (a === b) return 0;

  const visited = Array(N).fill(false);
  const queue = [[a, 0]];
  visited[a] = true;

  let head = 0;
  while (head < queue.length) {
    const [cur, dist] = queue[head++];
    const step = stones[cur];

    for (let next = cur + step; next < N; next += step) {
      if (!visited[next]) {
        if (next === b) return dist + 1;
        visited[next] = true;
        queue.push([next, dist + 1]);
      }
    }
    for (let next = cur - step; next >= 0; next -= step) {
      if (!visited[next]) {
        if (next === b) return dist + 1;
        visited[next] = true;
        queue.push([next, dist + 1]);
      }
    }
  }

  return -1;
};

const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");
console.log(solution(input));
```

## 복잡도

- 시간: O(N²)
- 공간: O(N)
