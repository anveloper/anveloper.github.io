---
title: "BOJ 2659 - 십자카드 문제"
date: "2025-07-15"
description: "구현, 브루트포스 알고리즘, 정렬 문제"
tags: ["구현", "브루트포스 알고리즘", "정렬", "집합과 맵"]
platform: "boj"
problem_number: "2659"
problem_url: "https://www.acmicpc.net/problem/2659"
difficulty: "실버 III"
language: "python"
---

## 문제

[BOJ 2659 - 십자카드 문제](https://www.acmicpc.net/problem/2659)

## 풀이

정렬을 활용하여 문제를 해결한다.

## 코드

```python
import sys

nums = list(map(int, sys.stdin.readline().split()))


def get_clock_num(n):
    min = int("".join(map(str, n)))
    for i in range(1, 4):
        tmp = int("".join(map(str, n[i:] + n[:i])))
        if min > tmp:
            min = tmp
    return min


clk_num = get_clock_num(nums)
cnt = 1

for i in range(1111, clk_num):
    if "0" not in list(str(i)) and i == get_clock_num(list(map(int, str(i)))):
        cnt += 1
print(cnt)
```

## 복잡도

- 시간: O(N²)
- 공간: O(N)
